<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.jpg">
  <link rel="mask-icon" href="/images/favicon.ico.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Protobuf研究简介​		Protobuf，全称为Protocol Buffers，是Google开发的一种轻量、高效的结构化数据存储格式，主要目标是实现高效的数据序列化和反序列化。它提供了一种简洁明了的结构化描述语言，来定义结构数据，同时提供对应的工具，生成多种编程语言的代码，从而实现跨平台，多语言支持。 特性 丰富的数据类型 支持基本数据类型（如整数、浮点数、布尔值等）、枚举、结构体、嵌套">
<meta property="og:type" content="article">
<meta property="og:title" content="WNN的极乐空间">
<meta property="og:url" content="http://example.com/2024/07/30/LearnDoc/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0/Protobuf/test/index.html">
<meta property="og:site_name" content="WNN的极乐空间">
<meta property="og:description" content="Protobuf研究简介​		Protobuf，全称为Protocol Buffers，是Google开发的一种轻量、高效的结构化数据存储格式，主要目标是实现高效的数据序列化和反序列化。它提供了一种简洁明了的结构化描述语言，来定义结构数据，同时提供对应的工具，生成多种编程语言的代码，从而实现跨平台，多语言支持。 特性 丰富的数据类型 支持基本数据类型（如整数、浮点数、布尔值等）、枚举、结构体、嵌套">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/.%5Coptimize.png">
<meta property="article:published_time" content="2024-07-30T09:42:08.762Z">
<meta property="article:modified_time" content="2024-07-23T07:08:04.959Z">
<meta property="article:author" content="急速老登">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.%5Coptimize.png">

<link rel="canonical" href="http://example.com/2024/07/30/LearnDoc/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0/Protobuf/test/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | WNN的极乐空间</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WNN的极乐空间</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>总目录</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/30/LearnDoc/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0/Protobuf/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="急速老登">
      <meta itemprop="description" content="我爱睡觉我爱睡觉我爱睡觉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WNN的极乐空间">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-30 17:42:08" itemprop="dateCreated datePublished" datetime="2024-07-30T17:42:08+08:00">2024-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-23 15:08:04" itemprop="dateModified" datetime="2024-07-23T15:08:04+08:00">2024-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Protobuf研究"><a href="#Protobuf研究" class="headerlink" title="Protobuf研究"></a>Protobuf研究</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		Protobuf，全称为Protocol Buffers，是Google开发的一种轻量、高效的结构化数据存储格式，主要目标是实现高效的数据序列化和反序列化。它提供了一种简洁明了的结构化描述语言，来定义结构数据，同时提供对应的工具，生成多种编程语言的代码，从而实现跨平台，多语言支持。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>丰富的数据类型</p>
<p>支持基本数据类型（如整数、浮点数、布尔值等）、枚举、结构体、嵌套消息、数组和map等复杂数据类型</p>
<p>使用repeated字段规则实现数组，可以不必指定数组大小</p>
</li>
<li><p>支持多种编程语言</p>
<p>C++、C#、Go、Ruby、Python、Java、PHP、Objective-C等</p>
</li>
<li><p>数据压缩</p>
<p>以int类型的变量为例，当其值为1时，只需要占用一个字节，而不是4个字节</p>
</li>
<li><p>语法简洁</p>
</li>
<li><p>方便扩展</p>
</li>
<li><p>兼容性好</p>
<p>当数据结构定义发生变化时，在解析老数据时，可以正常解析</p>
</li>
</ul>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Protobuf最初发布时，支持的版本为proto2，从Protobuf 3.0开始，推出proto3，默认为proto2，如果要使用proto3的语法，需要在.proto文件开头指定syntax &#x3D; “proto3”。</p>
<p>proto3相对proto2的主要修改如下：</p>
<ul>
<li>proto2的字段规则有三种：required、optional、repeated，每个字段都必须指定一种字段规则，在proto3中移除了required，只支持optional和repeated，如果没为字段指定规则，则字段可以不赋值</li>
<li>对于不指定字段规则的字段，不能使用has_xxx()函数是否有值，因为总会有一个默认值</li>
<li>如果在proto3中指定了optional规则，可以继续使用has_xxx()函数，来判断字段是否有值</li>
<li>移除了default关键字，不能为字段指定默认值，如果不给字段赋值，则序列化时跳过此变量，使用系统默认值</li>
<li>枚举类型，第一个枚举值必须为0，而proto2可为任意数值</li>
<li>对于数值型的repeated字段，在proto2中需要手动指定[packed&#x3D;true]，在proto3中默认就指定了[packed&#x3D;true]，此限定可大大降低序列化后的包大小</li>
<li>在proto2中，如果解析时，遇到未知字段，会跳过，继续解析后面的数据，proto3会直接报错</li>
<li>移除proto2中的extension</li>
<li>新增Any类型，可以存储任意类型数据</li>
<li>支持更多语言</li>
</ul>
<p>原生Protobuf不支持lua，如果要生成Lua代码，需要protoc-gen-lua插件，但是这个插件支持的protobuf比较老，对Protobuf3的支持程序未知，需要再研究</p>
<p>在最新的27.x版本中，改为使用edition取代syntax &#x3D; “proto2”和syntax &#x3D; “proto3”，可以使用官方提供的prototiller工具将旧的proto文件转成edition版本，详细的说明见<a target="_blank" rel="noopener" href="https://protobuf.com.cn/editions/">https://protobuf.com.cn/editions/</a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/protocolbuffers/protobuf</span><br><span class="line">cd protobuf</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<p>使用cmake工具编译源码，不同版本的protobuf，CMakeLists.txt文件所在位置不同，以3.18版本为例，CMakeLists.txt放在cmake目录下</p>
<h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>使用cmake工具来编译</p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>cmake、visual studio</p>
<h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>cmake、g++</p>
<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir builddir</span><br><span class="line">cd builddir</span><br><span class="line">cmake ../cmake  -DCMAKE_INSTALL_PREFIX=./install # cmake自己侦测编译器</span><br><span class="line">//如果要编译动态库版本，使用下面命令</span><br><span class="line">//cmake ../cmake -DBUILD_SHARED_LIBS=1 -DCMAKE_INSTALL_PREFIX=./install</span><br><span class="line">cmake --build . --config release --target install #编译release版本</span><br><span class="line">cmake --build . --config debug --target install #编译debug版本</span><br></pre></td></tr></table></figure>

<p>-DCMAKE_INSTALL_PREFIX用于指定安装目录</p>
<p>编译安装完成后，会生成以下文件：</p>
<ul>
<li><p>install&#x2F;lib&#x2F;libprotobuf.lib </p>
<p>完整功能的库文件</p>
</li>
<li><p>install&#x2F;lib&#x2F;libprotobuf-lite.lib </p>
<p>保留基础的序列化、反序列化功能，在libprotobuf.lib的基础上，精简了反射等功能，因此库文件会更小，大约是libprotobuf.lib的1&#x2F;7左右。</p>
<p>若要使用libprotobuf-lite.lib，需要在.proto文件中，指定option optimize_for &#x3D; LITE_RUNTIME;;</p>
</li>
<li><p>install&#x2F;bin&#x2F;protoc.exe</p>
<p>用于解析.proto文件，生成指定语言的代码文件</p>
</li>
<li><p>install&#x2F;include</p>
<p>头文件目录</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在.proto文件中定义消息，定义消息时，需要为每一个字段分配一个序号，序号为正数，不可重复，最大支持2 ^ 29 - 1个字段，19000 - 19999之间是Protobuf的保留字段，不要使用，protobuf虽然支持很大的字段序号，但是字段越大，需要的存储空间越大，编码效率也越低，所以，建议从1开始，顺序递增。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;<span class="comment">//指定使用proto3语法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// package Test;//命名空间，或者包，可有可无，看需要</span></span><br><span class="line"><span class="comment">// import &quot;other_proto.proto&quot;; //导入另一个proto文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TestMessage</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32</span>	i32 = <span class="number">1</span>;</span><br><span class="line">	<span class="type">sint32</span>	si32 = <span class="number">2</span>;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义好协议之后，使用protoc.exe工具，生成指定语言的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//生成C++代码</span><br><span class="line">protoc.exe --cpp_out=out_dir --proto_path=proto_path *.proto	//--proto_path指定proto文件搜索路径</span><br><span class="line"></span><br><span class="line">//生成C#代码</span><br><span class="line">protoc.exe --csharp_out=out_dir --proto_path=proto_path*.proto</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>protobuf支持以下数据类型:</p>
<table>
<thead>
<tr>
<th>protobuf</th>
<th>C++</th>
<th>C#</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>bool</td>
<td>bool</td>
<td>默认值false</td>
</tr>
<tr>
<td>int32</td>
<td>int32</td>
<td>int</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>int64</td>
<td>int64</td>
<td>long</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>uinit32</td>
<td>uint32</td>
<td>uint</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>uint64</td>
<td>uint64</td>
<td>ulong</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>sint32</td>
<td>int32</td>
<td>int</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>sint64</td>
<td>int64</td>
<td>long</td>
<td>varint变长编码</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint32</td>
<td>uint</td>
<td>固定4字节</td>
</tr>
<tr>
<td>fixed64</td>
<td>uint64</td>
<td>ulong</td>
<td>固定8字节</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int32</td>
<td>int</td>
<td>固定4字节</td>
</tr>
<tr>
<td>sfixed64</td>
<td>int64</td>
<td>long</td>
<td>固定8字节</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>string</td>
<td>UTF8编码格式的字符串</td>
</tr>
<tr>
<td>bytes</td>
<td>string</td>
<td>ByteString</td>
<td>字节序列</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>float</td>
<td>4字节</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
<td>double</td>
<td>8字节</td>
</tr>
<tr>
<td>enum</td>
<td>enum</td>
<td>enum</td>
<td>varint变长编码</td>
</tr>
</tbody></table>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>protobuf对不同的数值型字段，使用两种编码方式：</p>
<ul>
<li><p>varint变长编码</p>
<p>适应于int32、int64、uint32、uint64、sint32、sint64、enum、bool等</p>
<p>越小的数，占用的字节数越少，规则为：</p>
<ol>
<li>每个字节的最高位为标志位，为0表示当前是最后一个字节，为1表示后面的BYTE还是当前字段的数据</li>
<li>每个字节的后7位，表示实际的数据</li>
<li>采用小端字节序</li>
</ol>
<p>具体表示方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>^<span class="number">7</span> <span class="number">-1</span>]   		 <span class="number">0</span>xxxxxxx</span><br><span class="line">[<span class="number">2</span>^<span class="number">7</span>，<span class="number">2</span>^<span class="number">14</span> <span class="number">-1</span>]		<span class="number">1</span>xxxxxxx <span class="number">0</span>xxxxxxx</span><br><span class="line">[<span class="number">2</span>^<span class="number">14</span>, <span class="number">2</span>^<span class="number">21</span> <span class="number">-1</span>]		 <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">0</span>xxxxxxx</span><br><span class="line">[<span class="number">2</span>^<span class="number">21</span>, <span class="number">2</span>^<span class="number">28</span> <span class="number">-1</span>]		 <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">0</span>xxxxxxx</span><br><span class="line">[<span class="number">2</span>^<span class="number">28</span>, <span class="number">2</span>^<span class="number">35</span> <span class="number">-1</span>]		 <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">1</span>xxxxxxx <span class="number">0</span>xxxxxxx</span><br></pre></td></tr></table></figure>

<p>因为每个字节只有7位用来表示具体数值，所以，要完整表示一个32位数值，最多需要用到5个字节，同理，要完整表示一个64位数值，最多需要用到10个字节。</p>
<p>在数据类型部分，可以看到int32和sint32对应的C++类型都是int，这两者之间有什么区别呢？测试proto如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message Int32Message</span><br><span class="line">&#123;</span><br><span class="line">    int32 value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SInt32Message</span><br><span class="line">&#123;</span><br><span class="line">    sint32 value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置value &#x3D; -1，然后查看序列化后的值，输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 msg size <span class="number">11</span>, sint32 msg size <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>int32类型的-1，占用了10个字节（11个字节中的第一个字节，存储字段序号），在protobuf的源码中，针对负数的序列化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CodedOutputStream::WriteVarint32SignExtended</span><span class="params">(int32 value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">WriteVarint64</span>(<span class="built_in">static_cast</span>&lt;uint64&gt;(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">WriteVarint32</span>(<span class="built_in">static_cast</span>&lt;uint32&gt;(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负的int32字段，会调用WriteVarint64，当成一个64位int的最大值来处理，刚好是10个字节</p>
<p>而sint32字段，-1只占用一个字节的大小，这是因为sint32采用了zigzag编码</p>
</li>
<li><p>zigzag编码</p>
<p>sint32、sint64类型</p>
<p>zigzag将有符号数统一映射到无符号数，详细映射规则如下表：</p>
<table>
<thead>
<tr>
<th>Signed Original</th>
<th>映射为</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>-2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483647</td>
<td>4294967295</td>
</tr>
</tbody></table>
<p>然后，对映射后的数值，采用varint编码，所以sint32类型的-1只需要一个字节来表示。</p>
</li>
<li><p>固定长度编码</p>
<p>fixed32、sfixed32、float 固定占用4个字节</p>
<p>fixed64、sfixed64、double固定占用8个字节</p>
</li>
<li><p>Length-delimited</p>
<p>对于string、bytes、内嵌message、repeated字段，使用这种方式，先写data数据长度，再写实际数据，数据长度用varint编码方式</p>
</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>protobuf在不同的字段类型，进行了分类，每一类都对应一个TypeID，如下：</p>
<table>
<thead>
<tr>
<th>Type ID</th>
<th>Name</th>
<th>Used For</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>varint</td>
<td>int32、int64、uint32、uint64、sint32、sint64、enum、bool</td>
</tr>
<tr>
<td>1</td>
<td>i64</td>
<td>fixed64、sfixed64、double</td>
</tr>
<tr>
<td>2</td>
<td>LEN</td>
<td>string、bytes、内嵌消息、packed repeated字段</td>
</tr>
<tr>
<td>3</td>
<td>SGROUP</td>
<td>废弃</td>
</tr>
<tr>
<td>4</td>
<td>EGROUP</td>
<td>废弃</td>
</tr>
<tr>
<td>5</td>
<td>i32</td>
<td>fixed32、sfixed32、float</td>
</tr>
</tbody></table>
<p>序列化一个字段时，需要写入</p>
<ul>
<li><p>字段序号</p>
</li>
<li><p>字段编码类型TypeID</p>
</li>
<li><p>实际数据</p>
</li>
</ul>
<p>为了节省空间，Protobuf将字段序号和TypeID组合到一起，有一个专门的名词叫做Tag</p>
<p>对于TypeID为0、1、5的字段，写入格式为Tag | Data</p>
<p>对于TypeID为2的字段，写入格式为Tag | DataLen | Data</p>
<p>以string为例，序列化步骤如下：</p>
<ol>
<li>计算Tag &#x3D; 字段序号 &lt;&lt; 3 + TypeID</li>
<li>计算Tag的varint编码</li>
<li>将Tag写入输出缓冲区(小端字节序)</li>
<li>计算字符串长度的varint编码StrLen</li>
<li>将StrLen写入输出缓冲区(小端字节序)</li>
<li>将string的实际数据写入输出缓冲区</li>
</ol>
<p>在源码中，对字段的序列化处理都在类WireFormatLite中，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint8_t</span>* <span class="title">WireFormatLite::WriteInt32ToArray</span><span class="params">(<span class="type">int</span> field_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">int32_t</span> value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  target = <span class="built_in">WriteTagToArray</span>(field_number, WIRETYPE_VARINT, target);<span class="comment">//写Tag</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteInt32NoTagToArray</span>(value, target);<span class="comment">//写实际数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>在反序化时，调用Message::ParseFromArray函数，经过一系列处理后，会调用虚函数_InternalParse进行实际的数据读取和解析，伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *MyMessage::_InternalParse(<span class="type">const</span> <span class="type">char</span> *ptr, ::pbi::ParseContex* ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ctx-&gt;<span class="built_in">Done</span>(&amp;ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        ::pbi::<span class="built_in">ReadTag</span>(ptr, &amp;tag);<span class="comment">//读取Tag</span></span><br><span class="line">        解析字段序号<span class="function">FieldNum</span></span><br><span class="line"><span class="function">        <span class="title">switch</span><span class="params">(FieldNum)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> XXX:</span><br><span class="line">                读取并解析实际数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="数值字段性能"><a href="#数值字段性能" class="headerlink" title="数值字段性能"></a>数值字段性能</h3><p>protobuff中，不同的字段类型，其编码形式不一样，不同的编码方式对性能有什么样的影响呢？</p>
<p>以int32、sint32、fixed32、sfixed32为例，测试数值型字段的序列化性能（64位可以参考32位字段），循环100W次的输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负值</span></span><br><span class="line">value = <span class="number">-1</span>, fixed32 serialize cost <span class="number">8938</span> 微秒</span><br><span class="line">value = <span class="number">-1</span>, sfixed32 serialize cost <span class="number">9092</span> 微秒</span><br><span class="line">value = <span class="number">-1</span>, int32 serialize cost <span class="number">13402</span> 微秒</span><br><span class="line">value = <span class="number">-1</span>, sint32 serialize cost <span class="number">9843</span> 微秒</span><br><span class="line"><span class="comment">//小整数    </span></span><br><span class="line">value = <span class="number">1</span>, fixed32 serialize cost <span class="number">8956</span> 微秒</span><br><span class="line">value = <span class="number">1</span>, sfixed32 serialize cost <span class="number">9125</span> 微秒</span><br><span class="line">value = <span class="number">1</span>, int32 serialize cost <span class="number">9931</span> 微秒</span><br><span class="line">value = <span class="number">1</span>, sint32 serialize cost <span class="number">9943</span> 微秒</span><br><span class="line"><span class="comment">//大整数    </span></span><br><span class="line">value = <span class="number">2147483647</span>, fixed32 serialize cost <span class="number">8913</span> 微秒</span><br><span class="line">value = <span class="number">2147483647</span>, sfixed32 serialize cost <span class="number">9140</span> 微秒</span><br><span class="line">value = <span class="number">2147483647</span>, int32 serialize cost <span class="number">10742</span> 微秒</span><br><span class="line">value = <span class="number">2147483647</span>, sint32 serialize cost <span class="number">10980</span> 微秒</span><br></pre></td></tr></table></figure>

<p>当值为负数时，fixed32、sfixed32性能基本相同，sint32耗时比前两者高出将近10%，int32因为把负数当成了64位int来处理，需要编码和序列化更多的字节，所以性能表现最差，比fixed32和sfixed32耗时高出40%多。</p>
<p>当值为小的正数时，sint32、int32比fixed32、sfixed32耗时高出接近10%，值越大，耗时越多。</p>
<h3 id="综合性能对比"><a href="#综合性能对比" class="headerlink" title="综合性能对比"></a>综合性能对比</h3><p>以游戏中的LCRetCharList消息为模板做测试，对比下Protobuf和packgenerator的性能</p>
<p>具体的消息定义可见测试工程源码，两种消息，都填充相同的内容</p>
<p>测试结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//protobuf创建消息并序列化</span></span><br><span class="line">serialize msg LCRetCharList, loop count <span class="number">1000000</span>, protobuf time used <span class="number">2934963</span> 微秒</span><br><span class="line"><span class="comment">//protobuf反序列化</span></span><br><span class="line">deserialize msg LCRetCharList, loop count <span class="number">1000000</span>, proto time used <span class="number">2950556</span> 微秒</span><br><span class="line"></span><br><span class="line"><span class="comment">//packgenerator序列化</span></span><br><span class="line">serialize msg LCRetCharList, loop count <span class="number">1000000</span>, packgenerator time used <span class="number">1094577</span> 微秒</span><br><span class="line"><span class="comment">//packgenerator反序列化</span></span><br><span class="line">deserialize msg LCRetCharList, loop count <span class="number">1000000</span>, packgenerator time used <span class="number">725070</span> 微秒</span><br></pre></td></tr></table></figure>

<p>packgenerator无论序列化还是反序列化，性能都比protobuf高出好几倍。</p>
<p>分析后，发现protobuf在对repeated字段，调用add_xxx时都会触发内存分配操作，这个是非常耗时的。</p>
<p>针对内存操作带来的性能开销，protobuf也提供了一种方案，即Arena机制。</p>
<h2 id="Arena分配机制"><a href="#Arena分配机制" class="headerlink" title="Arena分配机制"></a>Arena分配机制</h2><p>旨在降低C++版本中内存分配和回收的性能开销</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​		Arena维护一个内存块链表BlockList，在创建Arena对象时，预先分配一个内存块，并将其加入BlockList。创建Message和内部对象的时候，都是在分配好的内存块上执行placement new，从而避免触发new操作。Message对象内部会有一个变量，用来记录此Message所属的Arena，在对消息字段进行操作时，如果需要new，都在所属Arena上执行placement new。</p>
<p>​		Arena在创建时允许指定初始的内存块，如果不指定，则默认分配一个256Byte的内存块，内存块耗尽时，会触发扩容，创建一个新的内存块，并加入BlockList，新内存块的大小为上一个内存块的大小 * 2，最大不能超过设定的最大内存值。</p>
<p>​		使用Arena机制创建的message，不能手动delete，其生命周期与Arena对象相同，在Arena对象释放时，会统一释放在此Arena上创建出来的Message。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>Arena提供了三个构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Arena</span>();<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Arena</span>(<span class="type">char</span> *block, <span class="type">size_t</span> block_size);<span class="comment">//指定初始内存块和内存块大小</span></span><br><span class="line"><span class="built_in">Arena</span>(ArenaOptions ao);<span class="comment">//可以指定初始内存块、初始内存块大小、Arena最大内存块大小</span></span><br></pre></td></tr></table></figure>

<p>引入Arena机制后，修改LCRetCharList消息的创建如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/arena.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//预分配1M空间</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> block_size = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="type">char</span> *pArenaBlock = <span class="keyword">new</span> <span class="type">char</span>[block_size];</span><br><span class="line"><span class="built_in">Assert</span>(<span class="literal">nullptr</span> != pArenaBlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环测试性能</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建Arena对象</span></span><br><span class="line">    google::<span class="function">protobuf::Arena <span class="title">arena</span><span class="params">(pArenaBlock, block_size)</span></span>;</span><br><span class="line">    <span class="comment">//创建消息</span></span><br><span class="line">    <span class="keyword">auto</span> msg = google::protobuf::Arena::<span class="built_in">CreateMessage</span>&lt;LCRetCharList&gt;(&amp;arena);</span><br><span class="line">    <span class="built_in">Assert</span>(<span class="literal">nullptr</span> != msg);</span><br><span class="line">    <span class="comment">//消息创建后，其它操作跟之前保持一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行性能测试程序，记录输出结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">serialize msg LCRetCharList, loop count <span class="number">1000000</span>, protobuf time used <span class="number">1392924</span> 微秒</span><br><span class="line">serialize msg LCRetCharList, loop count <span class="number">1000000</span>, packgenerator time used <span class="number">951083</span> 微秒</span><br><span class="line">deserialize msg LCRetCharList, loop count <span class="number">1000000</span>, proto time used <span class="number">1529971</span> 微秒</span><br><span class="line">deserialize msg LCRetCharList, loop count <span class="number">1000000</span>, packgenerator time used <span class="number">722319</span> 微秒</span><br></pre></td></tr></table></figure>

<p>protobuf在创建消息，并序列化操作上，耗时从293万微秒，减少到了139万微秒</p>
<p>在反序列化操作上，耗时从295万微秒，减少到了153万微秒</p>
<p>性能提升了50%左右。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在老版本的proto中，如果要使用arena分配，需要在proto文件中，显式开启 option cc_enable_arenas &#x3D; true;(3.18版本无需显式指定，之前的版本需要在使用时进行测试是否需要显式开启)</li>
<li>由于Arena分配的对象生命周期跟arena一样，不建议使用全局的Arena对象，这会导致进程的内存占用持续增长，建议每个message对应一个Arena，message使用完就即时释放。</li>
<li>假如消息中，没有repeated字段时，可以不使用Arena机制来创建message</li>
<li>字符串字段的内存分配操作不受Arena影响，始终是在堆上分配和释放</li>
<li>Arena线程安全</li>
<li>Message的移动构造、移动赋值、Swap函数：如果两个message都在堆上分配，或者在相同的arena分配，执行浅拷贝，否则执行深拷贝</li>
</ul>
<h2 id="空间占用"><a href="#空间占用" class="headerlink" title="空间占用"></a>空间占用</h2><p>在字符串和二进制数据的处理上，同常规思想一样，先写数据长度、再写实际数据，所以这两种数据的空间占用不是protobuf优化的重点。Protobuf区别于常规序列化思想的一点，就是数值字段的编码机制，采用varint编码，设计者不用操心一个字段应该是int8、int16、还是int32，统一使用int32，Protobuf来保证小的数值占用较少的存储空间，不仅优化了空间占用，也不用担心int8不够存了，需要将字段改为int16等，扩展性更强。</p>
<p>设计者需要关心的是：</p>
<ol>
<li>当有负值时，尽量使用sint，而不是int，无论在空间占用，还是性能上sint性能都更优</li>
<li>字段值如果是大数值（超过2^21），可以考虑使用fixed32，固定宽度的字段类型</li>
</ol>
<h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>分为三个级别：FileOptions、MessageOptions、FieldOptions，所有的option可以在descriptor.proto中找到</p>
<p>常用的option说明</p>
<ul>
<li><p>optimize_for</p>
<p>编译优化选项，FileOptions</p>
<ol>
<li><p>SPEED</p>
<p>默认选项，生成的代码拥有更快的运行速度，缺点是需要链接的库文件libprotobuf.lib比较大</p>
</li>
<li><p>CODE_SIZE</p>
<p>只重载Message中必要的函数，因此生成的代码行数较少，编译速度快一些，需要链接libprotobuf.lib库</p>
</li>
<li><p>LITE_RUNTIME</p>
<p>舍弃Descriptors和反射功能，链接libprotobuf-lite.lib，生成的可执行文件体积更小，适用于对资源要求苛刻的场景</p>
</li>
</ol>
<p>以LCRetCharList消息为测试模板，三种优化选项的性能对比如下图所示：</p>
<p><img src="/.%5Coptimize.png" alt="./optimize.png"></p>
<p>CODE_SIZE选项，性能极低，几乎是SPEED选项下的10倍耗时</p>
<p>LITE_RUNTIME选项的反序列化性能较低，是SPEED的两倍耗时</p>
<p>另外，Arena机制在CODE_SIZE优化选项下几乎没什么效果，性能只提升了5%左右</p>
<p>下表展示生成代码行数、可执行程序大小的对比：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>代码行数</th>
<th>可执行文件大小</th>
</tr>
</thead>
<tbody><tr>
<td>SPEED</td>
<td>1400</td>
<td>2M</td>
</tr>
<tr>
<td>CODE_SIZE</td>
<td>426</td>
<td>1.35M</td>
</tr>
<tr>
<td>LITE_RUNTIME</td>
<td>1296</td>
<td>500K</td>
</tr>
</tbody></table>
</li>
<li><p>cc_enable_arenas</p>
<p>FileOptions</p>
<p>是否开启Arena分配，true为开启，提升生成C++代码的性能</p>
</li>
<li><p>deprecated</p>
<p>如果某个proto文件废弃了，不想生成对应的代码，可以加这个选项 option deprecated &#x3D; true;</p>
<p>这个选项同样适用于字段、枚举定义等</p>
</li>
</ul>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ul>
<li>游戏项目中，优化选项保持默认的SPEED，追求运行效率</li>
<li>Arena机制对提升C++代码的性能，有显著效果，但是使用时，一定要做好封装，否则很容易出现内存相关的问题</li>
<li>不用的字段，最好使用reserved关键字声明一下，避免重用后导致的老数据解析问题</li>
<li>定义数值字段类型时，对有可能为负值的字段，使用sint32&#x2F;sint64类型</li>
<li>对于string字段类型，会做UTF8格式检查，如果不必做UTF8检查，建议使用bytes</li>
<li>字段序号从1开始，递增，尽量避免大序号</li>
<li>为兼容proto2和proto3语法，枚举类型的第一值建议用0</li>
</ul>
<h2 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h2><p>若要在项目中应用protobuf，需要修改：</p>
<ul>
<li><p>设计服务器&#x2F;客户端的胶水代码，适应当前项目框架</p>
</li>
<li><p>重新设计packgenerator生成的协议，由protoc.exe生成具体的协议代码，而packgenerator只负责生成胶水代码</p>
</li>
<li><p>protobuf不支持生成lua代码，需要引入第三方插件，或者自行实现</p>
</li>
<li><p>修改服务器和客户端底层的协议处理</p>
</li>
</ul>
<p>服务器的胶水代码大致设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LCRetCharListPak</span> : <span class="keyword">public</span> Packet</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LCRetCharList</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LCRetCharList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UINT	<span class="title">Execute</span><span class="params">(Player* pPlayer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PacketID_t <span class="title">GetPacketID</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> PACKET_LC_RETCHARLIST; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UINT	<span class="title">GetPacketSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (UINT)m_Message.<span class="built_in">ByteSizeLong</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LCRetCharList	m_Message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCRetCharListPakFactory</span> ：<span class="keyword">public</span> PacketFactoryBaseWithDestoryPacket</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Packet*	<span class="title">CreatePacket</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LCRetCharList</span>(); &#125;</span><br><span class="line">    <span class="function">PacketID_t <span class="title">GetPacketID</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> PACKET_LC_RETCHARLIST; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCRetCharListHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> UINT <span class="title">Execute</span><span class="params">(LCRetCharListPak* pPacket, Player *ppLayer)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>具体的Read&#x2F;Write，可以封装到底层，调用Message::SerializeToArray&#x2F;Message::ParseFromArray即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>protobuf本身具有多语言支持、跨平台、语法简洁等优势，非常适用于游戏中的前后端通信，同一个协议，程序员只需要在.proto文件中定义一份，然后使用工具生成不同语言的版本，可以避免使用多种语言重复定义同一个协议，最主要的是，可以保证前后端的数据在解析方式和解析顺序上的强一致，不会出现数据错乱的问题。</p>
<p>支持丰富的数据类型和字段规则，其repeated字段，对消息中数组类型支持更好，提供了丰富的访问接口，使编码时更加易于使用，而且程序员在定义消息时，无需关心数组上限。</p>
<p>是远程过程调用库gRPC的依赖，如果项目中用到了gRPC，那protobuf就是必须引进的库。</p>
<p>与项目中当前正在使用的pack generator工具相比：</p>
<ul>
<li><p>功能更丰富，支持optional、repeated、map等</p>
</li>
<li><p>支持import其它proto文件</p>
</li>
<li><p>扩展性更强</p>
</li>
<li><p>当消息中有repeated字段时，序列化和反序列化性能较差，即使使用Arena机制优化，开销还是比packgenerator高将近40%。</p>
</li>
<li><p>使用时，需要做进一步封装，以适用现有服务器的消息分发框架</p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/30/LearnDoc/%E7%BB%98%E7%94%BB/%E9%80%8F%E8%A7%86%E5%AD%A6%E4%B9%A0/" rel="prev" title="透视学习">
      <i class="fa fa-chevron-left"></i> 透视学习
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Protobuf%E7%A0%94%E7%A9%B6"><span class="nav-number">1.</span> <span class="nav-text">Protobuf研究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC"><span class="nav-number">1.3.</span> <span class="nav-text">版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">1.4.</span> <span class="nav-text">编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.1.</span> <span class="nav-text">下载源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="nav-number">1.4.2.</span> <span class="nav-text">准备编译环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#windows"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">linux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-number">1.7.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.8.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">1.10.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%AD%97%E6%AE%B5%E6%80%A7%E8%83%BD"><span class="nav-number">1.10.1.</span> <span class="nav-text">数值字段性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">1.10.2.</span> <span class="nav-text">综合性能对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arena%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">1.11.</span> <span class="nav-text">Arena分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">1.11.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.11.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8"><span class="nav-number">1.12.</span> <span class="nav-text">空间占用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#option"><span class="nav-number">1.13.</span> <span class="nav-text">option</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Attention"><span class="nav-number">1.14.</span> <span class="nav-text">Attention</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8"><span class="nav-number">1.15.</span> <span class="nav-text">项目应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.16.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="急速老登"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">急速老登</p>
  <div class="site-description" itemprop="description">我爱睡觉我爱睡觉我爱睡觉</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">总目录</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">

</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2d_models/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":400},"mobile":{"show":false}});</script></body>
</html>
